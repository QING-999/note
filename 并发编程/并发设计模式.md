# Immutability 不变模式

> 解决并发问题，其实最简单的办法就是让共享变量只有读操作，而没有写操作。不变性（Immutability）模式。所谓不变性指的就是对象一旦被创建之后，状态就不会再改变。也就是说，对象创建以后，就不允许修改了。

## 快速实现具备不可变性质的类

将一个类所有的属性都设置为final，并且只存在读方法，那么这个类基本上就具备不可变性了。更严格的做法是将类也设置为final的，这样就不允许继承。因为子类可以覆盖父类的方法，有可能改变不可变性。

Java SDK 里有很多啊类都具备不可变性。比如String、Long、Integer、Double。对于String的replace()方法，实际上是创建了一个新的不可变对象来返回。

## 利用享元模式(Flyweight Pattern)来避免创建重复对象

Long、Short、Byte等基本类型的包装类基本都用到了享元模式。

享元模式实际上就是利用对象池缓存对象。创建对象之前去判断对象池中是否存在，如果存在就利用对象池里面存在的对象。如果不存在则创建一个新的对象，并将对象存入对象池。

Long并没有照搬这种模式，它缓存了[-128,127] 之间的数字在对象池LongCache中。因为Long对象的状态太多了，有2^64 种，不适合全部缓存。而[-128,127] 之间的数字利用率较高，所以进行缓存。java 1.8之后的 valueOf() 就用到了这个缓存。

这也是前面提到Intege、String等类型不适合做锁的原因。看上去是私有的锁实际上却是共有的。例如下面，本意是A用锁al，B用锁bl。但是实际上用确实一个对象。

```java
class A {
  Long al=Long.valueOf(1);
  public void setAX(){
    synchronized (al) {
      // 省略代码无数
    }
  }
}
class B {
  Long bl=Long.valueOf(1);
  public void setBY(){
    synchronized (bl) {
      // 省略代码无数
    }
  }
}
```

## 注意事项

1.所有对象属性都是final的，并不能保证可变性

2.不可变对象也需要正确发布

在java中虽然final修饰的属性一旦被赋值了，就不能再更改，但是如果属性是普通对象，则是可以被更改的。例如下面，foo虽然是私有的，但是通过setAge还是能够设置foo中的属性age。**在使用 Immutability 模式的时候一定要确认保持不变性的边界在哪里，是否要求属性对象也具备不可变性**。

```java
class Foo{
  int age=0;
  int name="abc";
}
final class Bar {
  final Foo foo;
  void setAge(int a){
    foo.age=a;
  }
}
```

**如何发布不可变对象**

不可变对象虽然是线程安全的，但是不能保证引用不可变对象的对象是线程安全的。

```java
//Foo 线程安全
final class Foo{
  final int age=0;
  final int name="abc";
}
//Bar 线程不安全
class Bar {
  Foo foo;
  void setFoo(Foo f){
    this.foo=f;
  }
}
```

如果你的程序仅仅需要 foo 保持可见性，无需保证原子性，那么可以将 foo 声明为 volatile 变量，这样就能保证可见性。如果你的程序需要保证原子性，那么可以通过原子类来实现。

```java
public class SafeWM {
  class WMRange{
    final int upper;
    final int lower;
    WMRange(int upper,int lower){
    // 省略构造函数实现
    }
  }
  final AtomicReference<WMRange>
    rf = new AtomicReference<>(
      new WMRange(0,0)
    );
  // 设置库存上限
  void setUpper(int v){
    while(true){
      WMRange or = rf.get();
      // 检查参数合法性
      if(v < or.lower){
        throw new IllegalArgumentException();
      }
      WMRange nr = new
          WMRange(v, or.lower);
      if(rf.compareAndSet(or, nr)){
        return;
      }
    }
  }
}
```

# Copy-on-Write 模式

>  String的replay()并没有更改value[]数组里面的内容，而是创建了一个新字符串，其实这就是一种copy-on-write。所谓Copy-On-Write，常被缩写为COW或CoW，也就是写时复制。

java提供的容器中，CopyOnWriteList和CopyOnWriteSet它们背后的思想就是CopuOnWrite



# 线程本地存储模式ThreadLocal

没有共享变量自然就不会有并发问题，ThreadLocal就能让每个线程都能拥有自己的变量。

**使用**

如下方法可以为每一个线程分配一个id

```java
static class ThreadId {
        static final AtomicLong
                nextId = new AtomicLong(0);
        // 定义 ThreadLocal 变量
        static final ThreadLocal<Long> tl = ThreadLocal.withInitial(nextId::getAndIncrement);

        // 此方法会为每个线程分配一个唯一的 Id
        static long get() {
            return tl.get();
        }
    }
```

SimpleDateFormat不是线程安全的，但是使用ThreadLocal能让每一个线程获取不同的SimpleDateFormat对象，从而避免线程安全的问题

```java
static class SafeDateFormat {
  // 定义 ThreadLocal 变量
  static final ThreadLocal<DateFormat>
  tl=ThreadLocal.withInitial(
    ()-> new SimpleDateFormat(
      "yyyy-MM-dd HH:mm:ss"));
      
  static DateFormat get(){
    return tl.get();
  }
}
// 不同线程执行下面代码
// 返回的 df 是不同的
DateFormat df =
  SafeDateFormat.get()；
```

## ThreadLocal工作原理

java中在Thread中有个私有属性threadLocals，类型为ThreadLocalMap，这个map 的key是ThreadLocal。

![image-20210617224914494](E:\笔记\并发编程\.assets\image-20210617224914494.png)

```java
class Thread {
  // 内部持有 ThreadLocalMap
  ThreadLocal.ThreadLocalMap 
    threadLocals;
}
class ThreadLocal<T>{
  public T get() {
    // 首先获取线程持有的
    //ThreadLocalMap
    ThreadLocalMap map =
      Thread.currentThread()
        .threadLocals;
    // 在 ThreadLocalMap 中
    // 查找变量
    Entry e = 
      map.getEntry(this);
    return e.value;  
  }
  static class ThreadLocalMap{
    // 内部是数组而不是 Map
    Entry[] table;
    // 根据 ThreadLocal 查找 Entry
    Entry getEntry(ThreadLocal key){
      // 省略查找逻辑
    }
    //Entry 定义
    static class Entry extends
    WeakReference<ThreadLocal>{
      Object value;
    }
  }
}
```



为什么java要这样设计，将ThreadLocal放到ThreadLocalMap中，再将ThreadLocalMap放到Thread中，而是不是将ThreadLocal设计为一个map类型，其中key为Thread呢？

1.在java 的实现方案中ThreadLocal只是一个代理工具类，内部不持有与线程相关的数据，而与线程有关的数据存放在ThreadLocalMap中，ThreadLocalMap又存放在Thrad中，这样所有和线程相关的数据都存在线程中，这么设计更容易理解也更加的合理。

2.这样设计更**不容易发生内存泄露**。如果采用后一种设计，ThreadLocal持有的Map会持有Thread对象的引用，这样只有ThreadLocal对象存在，map中的Thread对象就永远不会回收。而ThreadLocal的生命周期往往都要比Thread长，这样很容易造成内存泄露。而java采用的方法是用Thrad持有ThreadLocalMap，并且ThreadLocalMap里面对ThreadLocal的引用还是弱引用，只要Thrad对象能够被回收ThradLocalMap就能够被回收。但是这样也不能完全避免内存泄露，比如使用线程池。

## 内存泄露问题

由于ThreadLocalMap中entry虽然对ThradLocal的引用是弱引用，但是对value的引用却是强引用。这就导致在线程池中长时间存在的线程，ThreadLocalMap不会被回收，并且Entry中的value也无法被回收，这就可能导致内存泄漏。

但是也可以通过手动释放的方法释放内存。利用try{}final{}就能做到

```java
ExecutorService es;
ThreadLocal tl;
es.execute(()->{
  //ThreadLocal 增加变量
  tl.set(obj);
  try {
    // 省略业务逻辑代码
  }finally {
    // 手动清理 ThreadLocal 
    tl.remove();
  }
});
```



## InheritableThreadLocal 与继承性

通过ThreadLocal创建的线程变量子类是无法继承的。但是通过ThreadLocal的子类InheritableThreadLocal创建的是能够继承的。与ThreadLocal类似，InheritableThreadLocal也有内存泄漏的问题。

## 总结

线程本地存储模式本质上是一种避免共享的方案，由于没有共享，所以自然也就没有并发问题。如果需要在并发场景中使用一个线程不安全的工具类，最简单的方案就是避免共享。避免共享有两种方案，一种方案是将这个工具类作为局部变量使用，另外一种方案就是线程本地存储模式。这两种方案，局部变量方案的缺点是在高并发场景下会频繁创建对象，而线程本地存储方案，每个线程只需要创建一个工具类的实例，所以不存在频繁创建对象的问题。

需要注意的是在线程池中使用 ThreadLocal 仍可能导致内存泄漏。



# Guarded Suspension模式：等待唤醒机制的规范实现

> GuardedSuspension模式本质是一个等待唤醒机制。线程等待一个条件满足后被唤醒，从而继续运行

![image-20210620214611357](E:\笔记\并发编程\.assets\image-20210620214611357.png)



```java
class GuardedObject<T>{
  // 受保护的对象
  T obj;
  final Lock lock = 
    new ReentrantLock();
  final Condition done =
    lock.newCondition();
  final int timeout=1;
  // 获取受保护对象  
  T get(Predicate<T> p) {
    lock.lock();
    try {
      //MESA 管程推荐写法
      while(!p.test(obj)){
        done.await(timeout, 
          TimeUnit.SECONDS);
      }
    }catch(InterruptedException e){
      throw new RuntimeException(e);
    }finally{
      lock.unlock();
    }
    // 返回非空的受保护对象
    return obj;
  }
  // 事件通知方法
  void onChanged(T obj) {
    lock.lock();
    try {
      this.obj = obj;
      done.signalAll();
    } finally {
      lock.unlock();
    }
  }
}
```

GuardedSuspension模式可以看成是多线程版本的if，在单线程中，如果线程被阻塞了，if的结果是不会变化的，而在多线程中，if的结果则有可能发生改变。所以用多线程版本的if来理解这个模式会更简单。



# Balking模式：再谈线程安全的单例模式

> Guarded Suspension 模式，不同于单线程中的 if，这个“多线程版本的 if”是需要等待的，而且还很执着，必须要等到条件为真。但很显然这个世界，不是所有场景都需要这么执着，有时候我们还需要快速放弃。

需要快速放弃的一个常见的例子就是编辑器的自动保存功能，一般是隔一段时间自动存盘一次，但是如果没有修改则需要放弃存盘。

```java
class AutoSaveEditor{
  // 文件是否被修改过
  boolean changed=false;
  // 定时任务线程池
  ScheduledExecutorService ses = 
    Executors.newSingleThreadScheduledExecutor();
  // 定时执行自动保存
  void startAutoSave(){
    ses.scheduleWithFixedDelay(()->{
      autoSave();
    }, 5, 5, TimeUnit.SECONDS);  
  }
  // 自动存盘操作
  void autoSave(){
    if (!changed) {
      return;
    }
    changed = false;
    // 执行存盘操作
    // 省略且实现
    this.execSave();
  }
  // 编辑操作
  void edit(){
    // 省略编辑逻辑
    ......
    changed = true;
  }
}
```

**但是，很显然AutoSaveEditor不是线程安全的。因为共享变量changed的读写没有使用同步**，可以在修改changed的时候加锁

```java
// 自动存盘操作
void autoSave(){
  synchronized(this){
    if (!changed) {
      return;
    }
    changed = false;
  }
  // 执行存盘操作
  // 省略且实现
  this.execSave();
}
// 编辑操作
void edit(){
  // 省略编辑逻辑
  ......
  synchronized(this){
    changed = true;
  }
}  
```

 这么看起来Balking实际上也是一个多线程的if



## Balking模式的经典实现

```java
boolean changed=false;
// 自动存盘操作
void autoSave(){
  synchronized(this){
    if (!changed) {
      return;
    }
    changed = false;
  }
  // 执行存盘操作
  // 省略且实现
  this.execSave();
}
// 编辑操作
void edit(){
  // 省略编辑逻辑
  ......
  change();
}
// 改变状态
void change(){
  synchronized(this){
    changed = true;
  }
}
```

可以发现仅仅是将edit中对共享变量changed的修改提取到了change() 中，这样做的好处就是将并发处理逻辑和业务逻辑分开。

