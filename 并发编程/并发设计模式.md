# Immutability 不变模式

> 解决并发问题，其实最简单的办法就是让共享变量只有读操作，而没有写操作。不变性（Immutability）模式。所谓不变性指的就是对象一旦被创建之后，状态就不会再改变。也就是说，对象创建以后，就不允许修改了。

## 快速实现具备不可变性质的类

将一个类所有的属性都设置为final，并且只存在读方法，那么这个类基本上就具备不可变性了。更严格的做法是将类也设置为final的，这样就不允许继承。因为子类可以覆盖父类的方法，有可能改变不可变性。

Java SDK 里有很多啊类都具备不可变性。比如String、Long、Integer、Double。对于String的replace()方法，实际上是创建了一个新的不可变对象来返回。

## 利用享元模式(Flyweight Pattern)来避免创建重复对象

Long、Short、Byte等基本类型的包装类基本都用到了享元模式。

享元模式实际上就是利用对象池缓存对象。创建对象之前去判断对象池中是否存在，如果存在就利用对象池里面存在的对象。如果不存在则创建一个新的对象，并将对象存入对象池。

Long并没有照搬这种模式，它缓存了[-128,127] 之间的数字在对象池LongCache中。因为Long对象的状态太多了，有2^64 种，不适合全部缓存。而[-128,127] 之间的数字利用率较高，所以进行缓存。java 1.8之后的 valueOf() 就用到了这个缓存。

这也是前面提到Intege、String等类型不适合做锁的原因。看上去是私有的锁实际上却是共有的。例如下面，本意是A用锁al，B用锁bl。但是实际上用确实一个对象。

```java
class A {
  Long al=Long.valueOf(1);
  public void setAX(){
    synchronized (al) {
      // 省略代码无数
    }
  }
}
class B {
  Long bl=Long.valueOf(1);
  public void setBY(){
    synchronized (bl) {
      // 省略代码无数
    }
  }
}
```

## 注意事项

1.所有对象属性都是final的，并不能保证可变性

2.不可变对象也需要正确发布

在java中虽然final修饰的属性一旦被赋值了，就不能再更改，但是如果属性是普通对象，则是可以被更改的。例如下面，foo虽然是私有的，但是通过setAge还是能够设置foo中的属性age。**在使用 Immutability 模式的时候一定要确认保持不变性的边界在哪里，是否要求属性对象也具备不可变性**。

```java
class Foo{
  int age=0;
  int name="abc";
}
final class Bar {
  final Foo foo;
  void setAge(int a){
    foo.age=a;
  }
}
```

**如何发布不可变对象**

不可变对象虽然是线程安全的，但是不能保证引用不可变对象的对象是线程安全的。

```java
//Foo 线程安全
final class Foo{
  final int age=0;
  final int name="abc";
}
//Bar 线程不安全
class Bar {
  Foo foo;
  void setFoo(Foo f){
    this.foo=f;
  }
}
```

如果你的程序仅仅需要 foo 保持可见性，无需保证原子性，那么可以将 foo 声明为 volatile 变量，这样就能保证可见性。如果你的程序需要保证原子性，那么可以通过原子类来实现。

```java
public class SafeWM {
  class WMRange{
    final int upper;
    final int lower;
    WMRange(int upper,int lower){
    // 省略构造函数实现
    }
  }
  final AtomicReference<WMRange>
    rf = new AtomicReference<>(
      new WMRange(0,0)
    );
  // 设置库存上限
  void setUpper(int v){
    while(true){
      WMRange or = rf.get();
      // 检查参数合法性
      if(v < or.lower){
        throw new IllegalArgumentException();
      }
      WMRange nr = new
          WMRange(v, or.lower);
      if(rf.compareAndSet(or, nr)){
        return;
      }
    }
  }
}
```

# Copy-on-Write 模式

>  String的replay()并没有更改value[]数组里面的内容，而是创建了一个新字符串，其实这就是一种copy-on-write。所谓Copy-On-Write，常被缩写为COW或CoW，也就是写时复制。

java提供的容器中，CopyOnWriteList和CopyOnWriteSet它们背后的思想就是CopuOnWrite



# 线程本地存储模式ThreadLocal

没有共享变量自然就不会有并发问题，ThreadLocal就能让每个线程都能拥有自己的变量。

**使用**

如下方法可以为每一个线程分配一个id

```java
static class ThreadId {
        static final AtomicLong
                nextId = new AtomicLong(0);
        // 定义 ThreadLocal 变量
        static final ThreadLocal<Long> tl = ThreadLocal.withInitial(nextId::getAndIncrement);

        // 此方法会为每个线程分配一个唯一的 Id
        static long get() {
            return tl.get();
        }
    }
```

SimpleDateFormat不是线程安全的，但是使用ThreadLocal能让每一个线程获取不同的SimpleDateFormat对象，从而避免线程安全的问题

```java
static class SafeDateFormat {
  // 定义 ThreadLocal 变量
  static final ThreadLocal<DateFormat>
  tl=ThreadLocal.withInitial(
    ()-> new SimpleDateFormat(
      "yyyy-MM-dd HH:mm:ss"));
      
  static DateFormat get(){
    return tl.get();
  }
}
// 不同线程执行下面代码
// 返回的 df 是不同的
DateFormat df =
  SafeDateFormat.get()；
```

## ThreadLocal工作原理

java中在Thread中有个私有属性threadLocals，类型为ThreadLocalMap，这个map 的key是ThreadLocal。

![image-20210617224914494](.assets\image-20210617224914494.png)

```java
class Thread {
  // 内部持有 ThreadLocalMap
  ThreadLocal.ThreadLocalMap 
    threadLocals;
}
class ThreadLocal<T>{
  public T get() {
    // 首先获取线程持有的
    //ThreadLocalMap
    ThreadLocalMap map =
      Thread.currentThread()
        .threadLocals;
    // 在 ThreadLocalMap 中
    // 查找变量
    Entry e = 
      map.getEntry(this);
    return e.value;  
  }
  static class ThreadLocalMap{
    // 内部是数组而不是 Map
    Entry[] table;
    // 根据 ThreadLocal 查找 Entry
    Entry getEntry(ThreadLocal key){
      // 省略查找逻辑
    }
    //Entry 定义
    static class Entry extends
    WeakReference<ThreadLocal>{
      Object value;
    }
  }
}
```



为什么java要这样设计，将ThreadLocal放到ThreadLocalMap中，再将ThreadLocalMap放到Thread中，而是不是将ThreadLocal设计为一个map类型，其中key为Thread呢？

1.在java 的实现方案中ThreadLocal只是一个代理工具类，内部不持有与线程相关的数据，而与线程有关的数据存放在ThreadLocalMap中，ThreadLocalMap又存放在Thrad中，这样所有和线程相关的数据都存在线程中，这么设计更容易理解也更加的合理。

2.这样设计更**不容易发生内存泄露**。如果采用后一种设计，ThreadLocal持有的Map会持有Thread对象的引用，这样只有ThreadLocal对象存在，map中的Thread对象就永远不会回收。而ThreadLocal的生命周期往往都要比Thread长，这样很容易造成内存泄露。而java采用的方法是用Thrad持有ThreadLocalMap，并且ThreadLocalMap里面对ThreadLocal的引用还是弱引用，只要Thrad对象能够被回收ThradLocalMap就能够被回收。但是这样也不能完全避免内存泄露，比如使用线程池。

## 内存泄露问题

由于ThreadLocalMap中entry虽然对ThradLocal的引用是弱引用，但是对value的引用却是强引用。这就导致在线程池中长时间存在的线程，ThreadLocalMap不会被回收，并且Entry中的value也无法被回收，这就可能导致内存泄漏。

但是也可以通过手动释放的方法释放内存。利用try{}final{}就能做到

```java
ExecutorService es;
ThreadLocal tl;
es.execute(()->{
  //ThreadLocal 增加变量
  tl.set(obj);
  try {
    // 省略业务逻辑代码
  }finally {
    // 手动清理 ThreadLocal 
    tl.remove();
  }
});
```



## InheritableThreadLocal 与继承性

通过ThreadLocal创建的线程变量子类是无法继承的。但是通过ThreadLocal的子类InheritableThreadLocal创建的是能够继承的。与ThreadLocal类似，InheritableThreadLocal也有内存泄漏的问题。

## 总结

线程本地存储模式本质上是一种避免共享的方案，由于没有共享，所以自然也就没有并发问题。如果需要在并发场景中使用一个线程不安全的工具类，最简单的方案就是避免共享。避免共享有两种方案，一种方案是将这个工具类作为局部变量使用，另外一种方案就是线程本地存储模式。这两种方案，局部变量方案的缺点是在高并发场景下会频繁创建对象，而线程本地存储方案，每个线程只需要创建一个工具类的实例，所以不存在频繁创建对象的问题。

需要注意的是在线程池中使用 ThreadLocal 仍可能导致内存泄漏。



# Guarded Suspension模式：等待唤醒机制的规范实现

> GuardedSuspension模式本质是一个等待唤醒机制。线程等待一个条件满足后被唤醒，从而继续运行

![image-20210620214611357](.assets\image-20210620214611357.png)



```java
class GuardedObject<T>{
  // 受保护的对象
  T obj;
  final Lock lock = 
    new ReentrantLock();
  final Condition done =
    lock.newCondition();
  final int timeout=1;
  // 获取受保护对象  
  T get(Predicate<T> p) {
    lock.lock();
    try {
      //MESA 管程推荐写法
      while(!p.test(obj)){
        done.await(timeout, 
          TimeUnit.SECONDS);
      }
    }catch(InterruptedException e){
      throw new RuntimeException(e);
    }finally{
      lock.unlock();
    }
    // 返回非空的受保护对象
    return obj;
  }
  // 事件通知方法
  void onChanged(T obj) {
    lock.lock();
    try {
      this.obj = obj;
      done.signalAll();
    } finally {
      lock.unlock();
    }
  }
}
```

GuardedSuspension模式可以看成是多线程版本的if，在单线程中，如果线程被阻塞了，if的结果是不会变化的，而在多线程中，if的结果则有可能发生改变。所以用多线程版本的if来理解这个模式会更简单。



# Balking模式：再谈线程安全的单例模式

> Guarded Suspension 模式，不同于单线程中的 if，这个“多线程版本的 if”是需要等待的，而且还很执着，必须要等到条件为真。但很显然这个世界，不是所有场景都需要这么执着，有时候我们还需要快速放弃。

需要快速放弃的一个常见的例子就是编辑器的自动保存功能，一般是隔一段时间自动存盘一次，但是如果没有修改则需要放弃存盘。

```java
class AutoSaveEditor{
  // 文件是否被修改过
  boolean changed=false;
  // 定时任务线程池
  ScheduledExecutorService ses = 
    Executors.newSingleThreadScheduledExecutor();
  // 定时执行自动保存
  void startAutoSave(){
    ses.scheduleWithFixedDelay(()->{
      autoSave();
    }, 5, 5, TimeUnit.SECONDS);  
  }
  // 自动存盘操作
  void autoSave(){
    if (!changed) {
      return;
    }
    changed = false;
    // 执行存盘操作
    // 省略且实现
    this.execSave();
  }
  // 编辑操作
  void edit(){
    // 省略编辑逻辑
    ......
    changed = true;
  }
}
```

**但是，很显然AutoSaveEditor不是线程安全的。因为共享变量changed的读写没有使用同步**，可以在修改changed的时候加锁

```java
// 自动存盘操作
void autoSave(){
  synchronized(this){
    if (!changed) {
      return;
    }
    changed = false;
  }
  // 执行存盘操作
  // 省略且实现
  this.execSave();
}
// 编辑操作
void edit(){
  // 省略编辑逻辑
  ......
  synchronized(this){
    changed = true;
  }
}  
```

 这么看起来Balking实际上也是一个多线程的if



## Balking模式的经典实现

```java
boolean changed=false;
// 自动存盘操作
void autoSave(){
  synchronized(this){
    if (!changed) {
      return;
    }
    changed = false;
  }
  // 执行存盘操作
  // 省略且实现
  this.execSave();
}
// 编辑操作
void edit(){
  // 省略编辑逻辑
  ......
  change();
}
// 改变状态
void change(){
  synchronized(this){
    changed = true;
  }
}
```

可以发现仅仅是将edit中对共享变量changed的修改提取到了change() 中，这样做的好处就是将并发处理逻辑和业务逻辑分开。



在单例模式中，本质上还是一次初始化，所以也能够使用Balking模式

```java
class Singleton{
  private static volatile 
    Singleton singleton;
  // 构造方法私有化  
  private Singleton() {}
  // 获取实例（单例）
  public static Singleton 
  getInstance() {
    // 第一次检查
    if(singleton==null){
      synchronize{Singleton.class){
        // 获取锁后二次检查
        if(singleton==null){
          singleton=new Singleton();
        }
      }
    }
    return singleton;
  }
}
```

## 总结

Balking模式看起来和GuardedSupension模式没有多大的关系，Balking只需要同步锁就能解决，但是GuardedSupension模式需要用到管程这种并发原语。但是从应用的角度来看，他们都是解决“线程安全if”的语义。**不同之处在于Balking不需要等待if为真，而GuardedSupension模式则需要。**



# Thread-Per-Message模式：最简单实用的分工方法

解决并发问题，首先需要解决的就是分工问题，对于分工问题也有很多的设计模式。比如：Thread-Per-Message，Worker Thread模式，生产者-消费者。

现实世界里，很多事情我们都需要委托他人办理，委托他人代办有一个非常大的好处，那就是可以专心做自己的事了。在编程领域也有很多类似的需求，比如写一个 HTTP Server，很显然只能在主线程中接收请求，而不能处理 HTTP 请求，因为如果在主线程中处理 HTTP 请求的话，那同一时间只能处理一个请求，太慢了！怎么办呢？可以利用代办的思路，创建一个子线程，委托子线程去处理 HTTP 请求。

这种委托的方式，在并发领域被称为一种设计模式，就是Thread-per-Message模式，简而言之就是每一个任务分配一个子线程，这是一种简单的分工方法，实现起来也非常简单。

## 用 Thread 实现Thread-Per-Message模式

网络编程里最简单的程序当数 echo 程序了，echo 程序的服务端会原封不动地将客户端的请求发送回客户端。例如，客户端发送 TCP 请求"Hello World"，那么服务端也会返回"Hello World"。

```java
final ServerSocketChannel ssc = 
  ServerSocketChannel.open().bind(
    new InetSocketAddress(8080));
// 处理请求
try{
  while (true) {
    // 接收请求
    final SocketChannel sc = 
      serverSocketChannel.accept();
    Fiber.schedule(()->{
      try {
        // 读 Socket
        ByteBuffer rb = ByteBuffer
          .allocateDirect(1024);
        sc.read(rb);
        // 模拟处理请求
        LockSupport.parkNanos(2000*1000000);
        // 写 Socket
        ByteBuffer wb = 
          (ByteBuffer)rb.flip()
        sc.write(wb);
        // 关闭 Socket
        sc.close();
      } catch(Exception e){
        throw new UncheckedIOException(e);
      }
    });
  }//while
}finally{
  ssc.close();
}
```

可以不关心代码的实现，只要知道每一个请求都对应一个线程，这种方案毫无疑问是有很大的缺陷的：

java的线程和操作系统的线程是一一对应的，本质上是吧java线程的调度权交个操作系统，操作系统在这方面非常成熟，这样做的好处是稳定可靠，但是同样的继承了操作系统线程的缺陷，那就是创建成本高。为了解决这个问题，java在并发包里提供了线程池等工具类。但是这种方案并不是唯一的。

还有一种方案就是 **轻量级线程**，虽然在java领域知名度不高，但是在 go语言、lua里的协程，本质就是一种轻量级线程。轻量级线程创建的成本很低，基本和创建一个对象类似；并且创建的速度和内存占用比操作系统的线程至少有一个数量级的提升。所以使用轻量级线程来实现Thread-Per-Message方案非常合适。

OpenJDK中有一个Loom项目就是为了解决java轻量级线程的问题，在这个项目中轻量级线程被称为Fiber。



## 用Fiber实现Thread-Per-Message

https://wiki.openjdk.java.net/display/loom/Main



# Worker Thread 如何避免重复创建线程

> Worker Thread 模式可以类比现实世界里车间的工作模式：车间里的工人，有活儿了，大家一起干，没活儿了就聊聊天等着。Worker Thread 模式中**Worker Thread 对应到现实世界里，其实指的就是车间里的工人**。不过这里需要注意的是，**车间里的工人数量往往是确定的**。



![image-20210622232708689](.assets\image-20210622232708689.png)



通过上面的图，很容易就能想到用阻塞队列做任务池，然后创建固定数量的线程消费阻塞队列中的任务。其实你仔细想会发现，这个方案就是 Java 语言提供的**线程池**。

## 正确的创建线程池

1.使用有界队列

2.最好给线程赋予一个业务相关的名字，以便排查错误

3.即使使用默认拒绝策略也要写出来

```java
ExecutorService es = new ThreadPoolExecutor(
  50, 500,
  60L, TimeUnit.SECONDS,
  // 注意要创建有界队列
  new LinkedBlockingQueue<Runnable>(2000),
  // 建议根据业务需求实现 ThreadFactory
  r->{
    return new Thread(r, "echo-"+ r.hashCode());
  },
  // 建议根据业务需求实现 RejectedExecutionHandler
  new ThreadPoolExecutor.CallerRunsPolicy());

```

## 避免线程死锁

> 使用线程池还需要注意一种线程死锁的情况，如果线程不是相互独立的，而是有关系的，就有可能出现死锁的情况。具体可能表现为，程序运行一段时间就出现无响应的情况，监控数据看起来一切正常，但是实际上已经不正常工作了。

相关逻辑如下。一个大型任务分为两个阶段，第一个阶段的任务会等待第二个阶段的任务完成，两个阶段都使用了同一个线程池

![image-20210623210411856](.assets\image-20210623210411856.png)



```java
//L1、L2 阶段共用的线程池
ExecutorService es = Executors.
  newFixedThreadPool(2);
//L1 阶段的闭锁    
CountDownLatch l1=new CountDownLatch(2);
for (int i=0; i<2; i++){
  System.out.println("L1");
  // 执行 L1 阶段任务
  es.execute(()->{
    //L2 阶段的闭锁 
    CountDownLatch l2=new CountDownLatch(2);
    // 执行 L2 阶段子任务
    for (int j=0; j<2; j++){
      es.execute(()->{
        System.out.println("L2");
        l2.countDown();
      });
    }
    // 等待 L2 阶段任务执行完
    l2.await();
    l1.countDown();
  });
}
// 等着 L1 阶段任务执行完
l1.await();
System.out.println("end");
```



查看堆栈信息，能够发现两个线程都阻塞在l2.wait() 上了。

![image-20210623211734851](.assets\image-20210623211734851.png)

要解决这种问题，最简单的方式就是增加线程池的线程数，前提是任务不是非常多。还有一种方法就是使用不同的线程池。

​	

# 两段终止模式：如何优雅的终止线程

线程结束或者线程出现异常都能停止，这种停止很简单，但是如何在线程T1中，终止线程T2，给线程T2一个机会处理后事，而不是直接抹杀。

Thread的曾提供了一个Thread方法用于停止线程，这个方法采用的就是直接抹杀的方法，被终止的线程无法处理后事，所以这个方法早就停止使用了。

而后，有了一种成熟的方案，那就是两段终止模式。也就是将终止的过程分为两段。第一阶段是线程T1给线程T2发送终止命令，第二阶段是线程T2响应终止命令。

![image-20210623221827832](.assets\image-20210623221827832.png)



从前面的线程状态流转图中可以知道，想要进入终止状态（Terminated）首先要进入Runnable状态，但是线程当前有可能处在休眠状态，那么就需要让线程进入Runnable状态，可以调用Tread类提供的方法interrupt()方法，它可以将线程从休眠状态切换到Runnable状态。

切换到Runnable状态后，需要考虑的就是如何终止了。优雅的方式是让线程执行完run() 方法，所以一般是设置一个**标志位**，然后在合适的时间检查这个标志位，如果发现符合终止条件，则自动退出run()方法。这个过程就是第二阶段，响应指令。

这样可以发现，终止指令包含两个内容 ：1.interrupt() 方法   2.线程终止标志位。

## 用两段模式终止监视操作

> 实际工作中，有些监控系统需要动态地采集一些数据，一般都是监控系统发送采集指令给被监控系统的监控代理，监控代理接收到指令之后，从监控目标收集数据，然后回传给监控系统，详细过程如下图所示。出于对性能的考虑（有些监控项对系统性能影响很大，所以不能一直持续监控），动态采集功能一般都会有终止操作。

![image-20210623222818085](.assets\image-20210623222818085.png)

```java
class Proxy {
  boolean started = false;
  // 采集线程
  Thread rptThread;
  // 启动采集功能
  synchronized void start(){
    // 不允许同时启动多个采集线程
    if (started) {
      return;
    }
    started = true;
    rptThread = new Thread(()->{
      while (!Thread.currentThread().isInterrupted()){
        // 省略采集、回传实现
        report();
        // 每隔两秒钟采集、回传一次数据
        try {
          Thread.sleep(2000);
        } catch (InterruptedException e){
          // 重新设置线程中断状态
          Thread.currentThread().interrupt();
        }
      }
      // 执行到此处说明线程马上终止
      started = false;
    });
    rptThread.start();
  }
  // 终止采集功能
  synchronized void stop(){
    //中断，让线程进入Runnable状态，并设置标志位
    rptThread.interrupt();
  }
}
```

需要注意的是，如果线程在Sleep的时候调用interrupt方法，会抛出中断异常，在捕获异常后jvm的异常处理会清除中断标志位，所以，在捕获了异常之后需要 **重新设置中断状态**

在实际工作中，如果run方法中调用的第三方的库，无法确定在第三方库汇总捕获了中断异常之后是否重新设置了中断状态，所以尽量使用自定义的标志位

```java
class Proxy {
  // 线程终止标志位
  volatile boolean terminated = false;
  boolean started = false;
  // 采集线程
  Thread rptThread;
  // 启动采集功能
  synchronized void start(){
    // 不允许同时启动多个采集线程
    if (started) {
      return;
    }
    started = true;
    terminated = false;
    rptThread = new Thread(()->{
      while (!terminated){
        // 省略采集、回传实现
        report();
        // 每隔两秒钟采集、回传一次数据
        try {
          Thread.sleep(2000);
        } catch (InterruptedException e){
          // 重新设置线程中断状态
          Thread.currentThread().interrupt();
        }
      }
      // 执行到此处说明线程马上终止
      started = false;
    });
    rptThread.start();
  }
  // 终止采集功能
  synchronized void stop(){
    // 设置中断标志位
    terminated = true;
    // 中断线程 rptThread
    rptThread.interrupt();
  }
}
```

terminated 上添加 volatile关键字是因为在start中另外开启了一个线程读取terminated，这样就会有可见性问题（sychronized只锁住了外层的线程，新建的线程没锁）。

## 终止线程池

线程池提供了两个方法 shutdown() 和 shutdownNow()

showdown() 方法很保守，首先会拒绝接收新的任务，会等待进入阻塞队列和正则正在执行的任务都完成之后，才最终关闭线程池。

showdownNow()则更为激进，在拒绝接收新的线程之后，阻塞队列中的任务会被剥夺执行的机会，并且还会中断正在运行的进程。需要使用该方法优雅的终止线程池时，提交到线程池的方法中需要正确的处理中断。

# 生产者-消费者模式：用流水线思想提高效率

> 核心是一个任务队列，生产者生产任务，并将任务提交到任务队列，消费者从任务队列中取出队列进行消费。

![image-20210624212434415](.assets\image-20210624212434415.png)

从架构设计的角度来看，生产者 - 消费者模式有一个很重要的优点，就是**解耦**。还有一个重要的优点就是**支持异步，并且能够平衡生产者和消费者的速度差异**



## 支持批量以提升性能

在前面提到的 [优雅的终止线程](#用两段模式终止监视操作) 中提到了监控案例，其实最终的数据还是要存入数据库的，但是被监控的系统往往有很多，如果每一条数据都INSERT一次，那么性能势必很差。如果采用批量的方法则能有效提高效率。

![image-20210624213921210](.assets\image-20210624213921210.png)

原来直接insert到数据库的线程作为生产线程，将需要插入的数据存入任务队列，消费者批量的从队列中获取数据然后批量保存。

```java
// 任务队列
BlockingQueue<Task> bq=new
  LinkedBlockingQueue<>(2000);
// 启动 5 个消费者线程
// 执行批量任务  
void start() {
  ExecutorService es=xecutors
    .newFixedThreadPool(5);
  for (int i=0; i<5; i++) {
    es.execute(()->{
      try {
        while (true) {
          // 获取批量任务
          List<Task> ts=pollTasks();
          // 执行批量任务
          execTasks(ts);
        }
      } catch (Exception e) {
        e.printStackTrace();
      }
    });
  }
}
// 从任务队列中获取批量任务
List<Task> pollTasks() 
    throws InterruptedException{
  List<Task> ts=new LinkedList<>();
  // 阻塞式获取一条任务
  Task t = bq.take();
  while (t != null) {
    ts.add(t);
    // 非阻塞式获取一条任务
    t = bq.poll();
  }
  return ts;
}
// 批量执行任务
execTasks(List<Task> ts) {
  // 省略具体代码无数
}
支持分阶段提交以提升性能
```

第一次采用阻塞的方式获取数据，不免不必要的循环。



## 分阶段提交以提升性能

> 如果写文件同步刷盘性能会很差，所以对于不是很重要额数据，往往采用异步刷盘的方式，比如一个日志组件：

刷盘时机：

1. ERROR 级别的日志需要立即刷盘；
2. 数据积累到 500 条需要立即刷盘；
3. 存在未刷盘数据，且 5 秒钟内未曾刷盘，需要立即刷盘。

这种操作实际上就是一种分段提交，



```java
class Logger {
  // 任务队列  
  final BlockingQueue<LogMsg> bq
    = new BlockingQueue<>();
  //flush 批量  
  static final int batchSize=500;
  // 只需要一个线程写日志
  ExecutorService es = 
    Executors.newFixedThreadPool(1);
  // 启动写日志线程
  void start(){
    File file=File.createTempFile(
      "foo", ".log");
    final FileWriter writer=
      new FileWriter(file);
    this.es.execute(()->{
      try {
        // 未刷盘日志数量
        int curIdx = 0;
        long preFT=System.currentTimeMillis();
        while (true) {
          LogMsg log = bq.poll(
            5, TimeUnit.SECONDS);
          // 写日志
          if (log != null) {
            writer.write(log.toString());
            ++curIdx;
          }
          // 如果不存在未刷盘数据，则无需刷盘
          if (curIdx <= 0) {
            continue;
          }
          // 根据规则刷盘
          if (log!=null && log.level==LEVEL.ERROR ||
              curIdx == batchSize ||
              System.currentTimeMillis()-preFT>5000){
            writer.flush();
            curIdx = 0;
            preFT=System.currentTimeMillis();
          }
        }
      }catch(Exception e){
        e.printStackTrace();
      } finally {
        try {
          writer.flush();
          writer.close();
        }catch(IOException e){
          e.printStackTrace();
        }
      }
    });  
  }
  // 写 INFO 级别日志
  void info(String msg) {
    bq.put(new LogMsg(
      LEVEL.INFO, msg));
  }
  // 写 ERROR 级别日志
  void error(String msg) {
    bq.put(new LogMsg(
      LEVEL.ERROR, msg));
  }
}
// 日志级别
enum LEVEL {
  INFO, ERROR
}
class LogMsg {
  LEVEL level;
  String msg;
  // 省略构造函数实现
  LogMsg(LEVEL lvl, String msg){}
  // 省略 toString() 实现
  String toString(){}
}
```



# 总结

## 避免共享的设计模式

Immutable模式，Copy-On-Write 模式，线程本地存储模式，**使用 Immutability 模式需要注意对象属性的不可变性，使用 Copy-on-Write 模式需要注意性能问题，使用线程本地存储模式需要注意异步执行问题**。

## 多线程版本的IF设计模式

Guarded Suspension、Balking两种模式都可以简单的看成是多线程版本的if模式，区别是前者会等待条件为真，后者不会。

Guarded Sunpension模式的经典实现是使用管程，当然也可以使用sleep，但是不建议使用sleep，sleep时间太长会影响性能，太短则会频繁的被唤醒。

实现 Balking 模式最容易忽视的就是**竞态条件问题**。在使用的过程中一定要先问问自己是否存在静态条件

```java
class Test{
  volatile boolean inited = false;
  int count = 0;
  void init(){
    // 存在竞态条件
    if(inited){
      return;
    }
    // 有可能多个线程执行到这里
    inited = true;
    // 计算 count 的值
    count = calc();
  }
}  
```

## 三种最简单的分工模式

Thread-Per-Manage、Worker Thread、生产者-消费者  这三种模式是最简单的多线程分工方法。

Thread-Per-Manage 模式在使用中需要注意频繁的创建和销毁线程是否会造成OOM，在高并发中解决这种OOM最简单的方法就是限流。

Worker Thread 模式在使用时需要注意死锁问题，共享线程池虽然能够提高效率，但是一定要保证任务之间没有依赖关系，否则就有可能出现死锁。



在生产者-消费者模式中，除了前面提到的两段终止模式，还有一种更简单的方法，叫做 ”毒丸“ 对象。简单来讲，”毒丸“就是生产者生产的一条特殊任务，当消费线程读到”毒丸“对象的时候会立刻终止自身的执行。

```java
class Logger {
  // 用于终止日志执行的“毒丸”
  final LogMsg poisonPill = 
    new LogMsg(LEVEL.ERROR, "");
  // 任务队列  
  final BlockingQueue<LogMsg> bq
    = new BlockingQueue<>();
  // 只需要一个线程写日志
  ExecutorService es = 
    Executors.newFixedThreadPool(1);
  // 启动写日志线程
  void start(){
    File file=File.createTempFile(
      "foo", ".log");
    final FileWriter writer=
      new FileWriter(file);
    this.es.execute(()->{
      try {
        while (true) {
          LogMsg log = bq.poll(
            5, TimeUnit.SECONDS);
          // 如果是“毒丸”，终止执行  
          if(poisonPill.equals(logMsg)){
            break;
          }  
          // 省略执行逻辑
        }
      } catch(Exception e){
      } finally {
        try {
          writer.flush();
          writer.close();
        }catch(IOException e){}
      }
    });  
  }
  // 终止写日志线程
  public void stop() {
    // 将“毒丸”对象加入阻塞队列
    bq.add(poisonPill);
    es.shutdown();
  }
}
```









