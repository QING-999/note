# Immutability 不变模式

> 解决并发问题，其实最简单的办法就是让共享变量只有读操作，而没有写操作。不变性（Immutability）模式。所谓不变性指的就是对象一旦被创建之后，状态就不会再改变。也就是说，对象创建杭州，就不允许修改了。

## 快速实现具备不可变性质的类

将一个类所有的属性都设置为final，并且只存在读方法，那么这个类基本上就具备不可变性了。更严格的做法是将类也设置为final的，这样就不允许继承。因为子类可以覆盖父类的方法，有可能改变不可变性。

Java SDK 里有很多啊类都具备不可变性。比如String、Long、Integer、Double。对于String的replace()方法，实际上是创建了一个新的不可变对象来返回。

## 利用享元模式(Flyweight Pattern)来避免创建重复对象

Long、Short、Byte等基本类型的包装类基本都用到了享元模式。

享元模式实际上就是利用对象池缓存对象。创建对象之前去判断对象池中是否存在，如果存在就利用对象池里面存在的对象。如果不存在则创建一个新的对象，并将对象存入对象池。

Long并没有照搬这种模式，它缓存了[-128,127] 之间的数字在对象池LongCache中。因为Long对象的状态太多了，有2^64 种，不适合全部缓存。而[-128,127] 之间的数字利用率较高，所以进行缓存。java 1.8之后的 valueOf() 就用到了这个缓存。

这也是前面提到Intege、String等类型不适合做锁的原因。看上去是私有的锁实际上却是共有的。例如下面，本意是A用锁al，B用锁bl。但是实际上用确实一个对象。

```java
class A {
  Long al=Long.valueOf(1);
  public void setAX(){
    synchronized (al) {
      // 省略代码无数
    }
  }
}
class B {
  Long bl=Long.valueOf(1);
  public void setBY(){
    synchronized (bl) {
      // 省略代码无数
    }
  }
}
```

## 注意事项

1.所有对象属性都是final的，并不能保证可变性

2.不可变对象也需要正确发布

在java中虽然final修饰的属性一旦被赋值了，就不能再更改，但是如果属性是普通对象，则是可以被更改的。例如下面，foo虽然是私有的，但是通过setAge还是能够设置foo中的属性age。**在使用 Immutability 模式的时候一定要确认保持不变性的边界在哪里，是否要求属性对象也具备不可变性**。

```java
class Foo{
  int age=0;
  int name="abc";
}
final class Bar {
  final Foo foo;
  void setAge(int a){
    foo.age=a;
  }
}
```

**如何发布不可变对象**

不可变对象虽然是线程安全的，但是不能保证引用不可变对象的对象是线程安全的。

```java
//Foo 线程安全
final class Foo{
  final int age=0;
  final int name="abc";
}
//Bar 线程不安全
class Bar {
  Foo foo;
  void setFoo(Foo f){
    this.foo=f;
  }
}
```

如果你的程序仅仅需要 foo 保持可见性，无需保证原子性，那么可以将 foo 声明为 volatile 变量，这样就能保证可见性。如果你的程序需要保证原子性，那么可以通过原子类来实现。

```java
public class SafeWM {
  class WMRange{
    final int upper;
    final int lower;
    WMRange(int upper,int lower){
    // 省略构造函数实现
    }
  }
  final AtomicReference<WMRange>
    rf = new AtomicReference<>(
      new WMRange(0,0)
    );
  // 设置库存上限
  void setUpper(int v){
    while(true){
      WMRange or = rf.get();
      // 检查参数合法性
      if(v < or.lower){
        throw new IllegalArgumentException();
      }
      WMRange nr = new
          WMRange(v, or.lower);
      if(rf.compareAndSet(or, nr)){
        return;
      }
    }
  }
}
```

# Copy-on-Write 模式

>  String的replay()并没有更改value[]数组里面的内容，而是创建了一个新字符串，其实这就是一种copy-on-write。所谓Copy-On-Write，常被缩写为COW或CoW，也就是写时复制。

java提供的容器中，CopyOnWriteList和CopyOnWriteSet它们背后的思想就是CopuOnWrite

