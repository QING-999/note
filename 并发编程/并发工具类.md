# Lock和Condition 并发包中的管程

> **Java SDK 并发包通过 Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题**。

在 Java 的 1.5 版本中，synchronized 性能不如 SDK 里面的 Lock，但 1.6 版本之后，synchronized 做了很多优化，将性能追了上来，但是为什么synchronized还是不能替代Lock？

在发生死锁的时候，使用synchronized是没有办法破坏不可抢占这个条件的。这就使得synchronized申请资源的时候，如果申请不到就直接进入阻塞状态，导致什么也干不了。

如果重新设计一个互斥锁来解决这个问题，需要解决这几个问题

1.**能够响应中断**，线程T1在持有资源A的时候如果申请资源B失败，进入阻塞状态。阻塞状态下需要能够响应中断信号，当我们给T1发送中断信号的时候，能够唤醒T1，这样T1就有机会释放占有资源A了。

2.**支持超时**，如果线程一段时间内没有获取到锁，那么久返回一个错误，好让线程能够有机会释放曾经持有的锁。

3.**非阻塞的获取锁**，如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。

这三种方案正好对应lock中的三个方法

```java
// 支持中断的 API
void lockInterruptibly() 
  throws InterruptedException;
// 支持超时的 API
boolean tryLock(long time, TimeUnit unit) 
  throws InterruptedException;
// 支持非阻塞获取锁的 API
boolean tryLock();
```

## **如何保证可见性**

Lock的使用有一个经典的返利，就是try() finaly()  在finaly()里面释放锁。java多线程的可见性是通过Happens-Before规则保证的，synchronized之所以能够保证可见性，是因为其中的：synchronized 的解锁 Happens-Before 于后续对这个锁的加锁。

### Lock如何保证可见性

```java
class X {
  private final Lock rtl =
  new ReentrantLock();
  int value;
  public void addOne() {
    // 获取锁
    rtl.lock();  
    try {
      value+=1;
    } finally {
      // 保证锁能释放
      rtl.unlock();
    }
  }
}
```

**利用了 volatile 相关的 Happens-Before 规则**。Java SDK 里面的 ReentrantLock，内部持有一个 volatile 的成员变量 state，获取锁的时候，会读写 state 的值；解锁的时候，也会读写 state 的值（简化后的代码如下面所示）。

```java
class SampleLock {
  volatile int state;
  // 加锁
  lock() {
    // 省略代码无数
    state = 1;
  }
  // 解锁
  unlock() {
    // 省略代码无数
    state = 0;
  }
}
```

也就是说，在执行 value+=1 之前，程序先读写了一次 volatile 变量 state，在执行 value+=1 之后，又读写了一次 volatile 变量 state。根据相关的 Happens-Before 规则：

1. **顺序性规则**：对于线程 T1，value+=1 Happens-Before 释放锁的操作 unlock()；
2. **volatile 变量规则**：由于 state = 1 会先读取 state，所以线程 T1 的 unlock() 操作 Happens-Before 线程 T2 的 lock() 操作；
3. **传递性规则**：线程 T1 的 value+=1 Happens-Before 线程 T2 的 lock() 操作。

## 可重入锁

> 所谓可重入锁，顾名思义，指的是线程可以重复获取同一把锁。

线程 T1 执行到 ① 处时，已经获取到了锁 rtl ，当在 ① 处调用 get() 方法时，会在 ② 再次对锁 rtl 执行加锁操作。此时，如果锁 rtl 是可重入的，那么线程 T1 可以再次加锁成功；如果锁 rtl 是不可重入的，那么线程 T1 此时会被阻塞。

```java
class X {
  private final Lock rtl =
  new ReentrantLock();
  int value;
  public int get() {
    // 获取锁
    rtl.lock();         ②
    try {
      return value;
    } finally {
      // 保证锁能释放
      rtl.unlock();
    }
  }
  public void addOne() {
    // 获取锁
    rtl.lock();  
    try {
      value = 1 + get(); ①
    } finally {
      // 保证锁能释放
      rtl.unlock();
    }
  }
}
```

## 公平锁与非公平锁

> 每一个锁都对应一个等待队列，释放锁的时候会从等待队列唤醒一个线程，如果是公平锁，唤醒策略就是谁等待的时间长就唤醒谁，非公平则不提供这个保证，有可能等待时间短的被先唤醒。

 ReentrantLock 这个类有两个构造函数，一个是无参构造函数（默认创建非公平锁），一个是传入 fair 参数的构造函数。fair 参数代表的是锁的公平策略，如果传入 true 就表示需要构造一个公平锁，反之则表示要构造一个非公平锁。

```java
// 无参构造函数：默认非公平锁
public ReentrantLock() {
    sync = new NonfairSync();
}
// 根据公平策略参数创建锁
public ReentrantLock(boolean fair){
    sync = fair ? new FairSync() 
                : new NonfairSync();
}
```

## 锁的最佳应用实践

并发大师 Doug Lea《Java 并发编程：设计原则与模式》一书中，推荐的三个用锁的最佳实践，它们分别是：

> 1. 永远只在更新对象的成员变量时加锁
> 2. 永远只在访问可变的成员变量时加锁
> 3. 永远不在调用其他对象的方法时加锁

最后一条你可能会觉得过于严苛。但是最好还是遵守，因为调用其他对象的方法，实在是太不安全了，也许“其他”方法里面有线程 sleep() 的调用，也可能会有奇慢无比的 I/O 操作，这些都会严重影响性能。更可怕的是，“其他”类的方法可能也会加锁，然后双重加锁就可能导致死锁。

## **Condition** 

Java语言内置的管程里只有一个条件变量，而Lock&Codition实现的管程是支持多个条件变量的

### 如何用两个条件变量快速实现阻塞队列

> 一个阻塞队列，需要两个条件变量，一个是队列不空（空队列不允许出队），另一个是队列不满（队列已满不允许入队），前面管程的笔记也有提到这个

```java
public class BlockedQueue<T>{
  final Lock lock =
    new ReentrantLock();
  // 条件变量：队列不满  
  final Condition notFull =
    lock.newCondition();
  // 条件变量：队列不空  
  final Condition notEmpty =
    lock.newCondition();
 
  // 入队
  void enq(T x) {
    lock.lock();
    try {
      while (队列已满){
        // 等待队列不满
        notFull.await();
      }  
      // 省略入队操作...
      // 入队后, 通知可出队
      notEmpty.signal();
    }finally {
      lock.unlock();
    }
  }
  // 出队
  void deq(){
    lock.lock();
    try {
      while (队列已空){
        // 等待队列不空
        notEmpty.await();
      }  
      // 省略出队操作...
      // 出队后，通知可入队
      notFull.signal();
    }finally {
      lock.unlock();
    }  
  }
}
```

==需要注意==Lock 和 Condition 实现的管程，**线程等待和通知需要调用 await()、signal()、signalAll()**，它们的语义和 wait()、notify()、notifyAll() 是相同的。但是不一样的是，Lock&Condition 实现的管程里只能使用前面的 await()、signal()、signalAll()，而后面的 wait()、notify()、notifyAll() 只有在 synchronized 实现的管程里才能使用。

# Dubbo中的Lock和Condition

> 在编程中异步的场景还是挺多的，比如TCP协议本身就是异步的，工作中经常用到的RPC调用，在TCP层面，发送完RPC请求后，线程是不会等待RPC的响应结果的。但是可以发现平时的RPC调用明明大多都是同步的，这一定是因为有人帮你做了异步转同步的操作。比如RPC框架Dubbo

对于这个简单的RPC调用，默认情况sayHello() 方法是个同步方法。执行sayHello()的时候线程会停下来等待结果。

```java
DemoService service = 初始化部分省略
String message = 
  service.sayHello("dubbo");
System.out.println(message);
```

如果这时候将线程dump出来会实这样一个结果

<img src="E:\笔记\并发编程\.assets\image-20210526222935763.png" alt="image-20210526222935763" style="zoom:67%;" />

调用线程阻塞了，线程状态是 TIMED_WAITING。本来发送请求是异步的，但是调用线程却阻塞了，说明 Dubbo 帮我们做了异步转同步的事情。通过调用栈，你能看到线程是阻塞在 DefaultFuture.get() 方法上，所以可以推断：Dubbo 异步转同步的功能应该是通过 DefaultFuture 这个类实现的。

不过为了理清前后关系，还是有必要分析一下调用 DefaultFuture.get() 之前发生了什么。DubboInvoker 的 108 行调用了 DefaultFuture.get()，这一行先调用了 request(inv, timeout) 方法，这个方法其实就是发送 RPC 请求，之后通过调用 get() 方法等待 RPC 返回结果。

DefaultFuture 这个类是很关键，把相关的代码精简之后，列到了下面。不过在看代码之前，明确一下需求：当 RPC 返回结果之前，阻塞调用线程，让调用线程等待；当 RPC 返回结果后，唤醒调用线程，让调用线程重新执行。这就是经典的等待 - 通知机制吗。来看看 Dubbo 是怎么实现的。

```java
// 创建锁与条件变量
private final Lock lock 
    = new ReentrantLock();
private final Condition done 
    = lock.newCondition();
 
// 调用方通过该方法等待结果
Object get(int timeout){
  long start = System.nanoTime();
  lock.lock();
  try {
	while (!isDone()) {
	  done.await(timeout);
      long cur=System.nanoTime();
	  if (isDone() || 
          cur-start > timeout){
	    break;
	  }
	}
  } finally {
	lock.unlock();
  }
  if (!isDone()) {
	throw new TimeoutException();
  }
  return returnFromResponse();
}
// RPC 结果是否已经返回
boolean isDone() {
  return response != null;
}
// RPC 结果返回时调用该方法   
private void doReceived(Response res) {
  lock.lock();
  try {
    response = res;
    if (done != null) {
      done.signal();
    }
  } finally {
    lock.unlock();
  }
}
```



# Semaphore

> Semaphore，现在普遍翻译为“信号量”，以前也曾被翻译成“信号灯”，因为类似现实生活里的红绿灯，车辆能不能通行，要看是不是绿灯。同样，在编程世界里，线程能不能执行，也要看信号量是不是允许。信号量是由大名鼎鼎的计算机科学家迪杰斯特拉（Dijkstra）于 1965 年提出，在这之后的 15 年，信号量一直都是并发编程领域的终结者，直到 1980 年管程被提出来，我们才有了第二选择。目前几乎所有支持并发编程的语言都支持信号量机制，所以学好信号量还是很有必要的。

semaphore对象适用于控制一个仅支持有限个用户的共享资源，是一种不需要使用忙碌等待（busy waiting）的方法。也就是说支持自定义数量的线程同时访问共享变量。这就是信号量存在的意义。

## 信号量模型

>  信号量模型还是很简单的，可以简单概括为：**一个计数器，一个等待队列，三个方法**。在信号量模型里，计数器和等待队列对外是透明的，所以只能通过信号量模型提供的三个方法来访问，init()、down() 和 up()

<img src="E:\笔记\并发编程\.assets\image-20210526224711384.png" alt="image-20210526224711384" style="zoom:67%;" />

- init()：设置计数器的初始值。
- down()：计数器的值减 1；如果此时计数器的值小于 0，则当前线程将被阻塞，否则当前线程可以继续执行。
- up()：计数器的值加 1；如果此时计数器的值小于或者等于 0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。

这里提到的 init()、down() 和 up() 三个方法都是原子性的，在 Java SDK 里面，信号量模型是由 java.util.concurrent.Semaphore 实现的，Semaphore 这个类能够保证这三个方法都是原子操作。



实现信号量

acquire相当于down操作，release相当于up操作

```java
static int count;
// 初始化信号量
static final Semaphore s 
    = new Semaphore(1);
// 用信号量保证互斥    
static void addOne() {
  s.acquire();
  try {
    count+=1;
  } finally {
    s.release();
  }
}
```

假设T1，T2同时执行。acquire是一个原子操作，只能有一个线程将Semaphore中的值-1。假设是T1，此时semaphore中的值为-1，小于0，那么T2就会阻塞，只有T1能对临界区中的count进行 + 1操作。当执行完count+1后，线程T1执行 release，将semahore中的值+1，此时该值=0，T2线程被唤醒。

这里的这种实现互斥锁的操作非常类似SDK里面的Lock，为什么有了lock还需要Semaphore呢？Semaphore还有一个功能是lock不好是实现的，那就是 **Semaphore允许多个线程访问同一个临界区**

比较常见的需求就是我们工作中遇到的各种池化资源，例如连接池、对象池、线程池等等。其中，你可能最熟悉数据库连接池，在同一时刻，一定是允许多个线程同时使用连接池的，当然，每个连接在被释放前，是不允许其他线程使用的。

例如限流器的实现：

## Semaphore快速实现一个限流器

假设有一个一个对象池，一次性创建出 N 个对象，存入对象池，之后所有的线程重复利用这 N 个对象，当然对象在被释放前，也是不允许其他线程使用的。对象池，可以用 List 保存实例对象，主要的是不允许多余N个线程同时进入临界区

```java
class ObjPool<T, R> {
  final List<T> pool;
  // 用信号量实现限流器
  final Semaphore sem;
  // 构造函数
  ObjPool(int size, T t){
    pool = new Vector<T>(){};
    for(int i=0; i<size; i++){
      pool.add(t);
    }
    sem = new Semaphore(size);
  }
  // 利用对象池的对象，调用 func
  R exec(Function<T,R> func) {
    T t = null;
    sem.acquire();
    try {
      t = pool.remove(0);
      return func.apply(t);
    } finally {
      pool.add(t);
      sem.release();
    }
  }
}
// 创建对象池
ObjPool<Long, String> pool = 
  new ObjPool<Long, String>(10, 2);
// 通过对象池获取 t，之后执行  
pool.exec(t -> {
    System.out.println(t);
    return t.toString();
});

```



# ReadWriteLock

> 理论上利用管程和信号量这两个原语在java中的实现，可以解决所有并发问题，那么SDK并发包里面为什么还有很多其他的工具类？为了 **分场景优化性能，提升易用性**
>
> ReadWriteLock 就是针对读多写少的场景进行的一个优化

读写锁，并不是 Java 语言特有的，而是一个广为使用的通用技术，所有的读写锁都遵守以下三条基本原则：

1. 允许多个线程同时读共享变量；
2. 只允许一个线程写共享变量；
3. 如果一个写线程正在执行写操作，此时禁止读线程读共享变量。

读写锁与互斥锁的一个重要区别就是**读写锁允许多个线程同时读共享变量**，但**读写锁的写操作是互斥的**，当一个线程在写共享变量的时候，是不允许其他线程执行写操作和读操作。

## 使用ReadWriteLock快速实现一个缓存工具类

声明了一个 Cache<K, V> 类，缓存的数据保存在 Cache 类内部的 HashMap 里面，HashMap 不是线程安全的，使用读写锁 ReadWriteLock 来保证其线程安全。ReadWriteLock 是一个接口，它的实现类是 ReentrantReadWriteLock，看名字就直达，它是支持可重入的。

```java
class Cache<K,V> {
  final Map<K, V> m =
    new HashMap<>();
  final ReadWriteLock rwl =
    new ReentrantReadWriteLock();
  // 读锁
  final Lock r = rwl.readLock();
  // 写锁
  final Lock w = rwl.writeLock();
  // 读缓存
  V get(K key) {
    r.lock();
    try { return m.get(key); }
    finally { r.unlock(); }
  }
  // 写缓存
  V put(String key, Data v) {
    w.lock();
    try { return m.put(key, v); }
    finally { w.unlock(); }
  }
}
```

具有按需加载功能的缓存

```java
class Cache<K,V> {
  final Map<K, V> m =
    new HashMap<>();
  final ReadWriteLock rwl = 
    new ReentrantReadWriteLock();
  final Lock r = rwl.readLock();
  final Lock w = rwl.writeLock();
 
  V get(K key) {
    V v = null;
    // 读缓存
    r.lock();         ①
    try {
      v = m.get(key); ②
    } finally{
      r.unlock();     ③
    }
    // 缓存中存在，返回
    if(v != null) {   ④
      return v;
    }  
    // 缓存中不存在，查询数据库
    w.lock();         ⑤
    try {
      // 再次验证
      // 其他线程可能已经查询过数据库
      v = m.get(key); ⑥
      if(v == null){  ⑦
        // 查询数据库
        v= 省略代码无数
        m.put(key, v);
      }
    } finally{
      w.unlock();
    }
    return v; 
  }
}
```

## 读写锁的升级与降级

上面代码，是否能在2处直接判断，是否存在，若不存在直接进行查询，获取写锁并写入呢？

```java
// 读缓存
r.lock();         
try {
  v = m.get(key); 
  if (v == null) {
    w.lock();
    try {
      // 再次验证并更新缓存
      // 省略详细代码
    } finally{
      w.unlock();
    }
  }
} finally{
  r.unlock();     
}
```

这样是不行的。这里先获取了读锁，在释放之前又去获取写锁，这种操作被称作 **锁升级**，这在读写锁里面是不允许的。此时获取写锁，会导致写锁永久等待相关线程都被阻塞，永远都没有机会被唤醒。

但是读写锁**支持锁降级**

## 总结

读写锁类似于 ReentrantLock，也支持公平模式和非公平模式。读锁和写锁都实现了 java.util.concurrent.locks.Lock 接口，所以除了支持 lock() 方法外，tryLock()、lockInterruptibly() 等方法也都是支持的。但是有一点需要注意，那就是 **只有写锁支持条件变量，读锁是不支持条件变量的**，读锁调用 newCondition() 会抛出 UnsupportedOperationException 异常。

# StampedLock

> 在读多写少的场景中，Java 在 1.8 这个版本里，提供了一种叫 StampedLock 的锁，它的性能就比读写锁还要好。

ReadWriteLock 支持两种模式：一种是读锁，一种是写锁。而 StampedLock 支持三种模式，分别是：**写锁**、**悲观读锁**和**乐观读**。其中，写锁、悲观读锁的语义和 ReadWriteLock 的写锁、读锁的语义非常类似，允许多个线程同时获取悲观读锁，但是只允许一个线程获取写锁，写锁和悲观读锁是互斥的。

不同的是：StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp。相关的示例代码如下。

```java
final StampedLock sl = 
  new StampedLock();
  
// 获取 / 释放悲观读锁示意代码
long stamp = sl.readLock();
try {
  // 省略业务相关代码
} finally {
  sl.unlockRead(stamp);
}
 
// 获取 / 释放写锁示意代码
long stamp = sl.writeLock();
try {
  // 省略业务相关代码
} finally {
  sl.unlockWrite(stamp);
}
```

StampedLock 的性能之所以比 ReadWriteLock 还要好，其关键是 StampedLock 支持乐观读的方式。ReadWriteLock 支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞；而 StampedLock 提供的**乐观读**，是允许一个线程获取写锁的，也就是说不是所有的写操作都被阻塞。

注意这里，用的是“乐观读”这个词，而不是“乐观读锁”，是要提醒你，**乐观读这个操作是无锁的**，所以相比较 ReadWriteLock 的读锁，乐观读的性能更好一些。

## 注意事项

**StampedLock 的功能仅仅是 ReadWriteLock 的子集**，StampedLock 在命名上并没有增加 Reentrant，StampedLock 不支持重入。并且，StampedLock的悲观读锁，写锁都不支持条件变量。

如果线程阻塞在 StampedLock 的 readLock() 或者 writeLock() 上时，此时调用该阻塞线程的 interrupt() 方法，会导致 CPU 飙升。**使用 StampedLock 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly() 和写锁 writeLockInterruptibly()**

StampedLock读模板

```java
final StampedLock sl = 
  new StampedLock();
 
// 乐观读
long stamp = 
  sl.tryOptimisticRead();
// 读入方法局部变量
......
// 校验 stamp
if (!sl.validate(stamp)){
  // 升级为悲观读锁
  stamp = sl.readLock();
  try {
    // 读入方法局部变量
    .....
  } finally {
    // 释放悲观读锁
    sl.unlockRead(stamp);
  }
}
// 使用方法局部变量执行业务操作
......
```

写模板

```java
long stamp = sl.writeLock();
try {
  // 写共享变量
  ......
} finally {
  sl.unlockWrite(stamp);
}		
```

**最后**

StampedLock **支持锁的降级**（通过 tryConvertToReadLock() 方法实现）**和升级**（通过 tryConvertToWriteLock() 方法实现）

# CountDownLatch和CyclicBarrier

## CountDownLatch 实现线程等待

假如主线程中有两个线程T1，T2。主线程需要等待两个线程执行完成，这时可以使用T1和T2的join()，方法等待他们之心完成。但是，如果线程T1，和T2，是在线程池中的线程，而线程池中的线程根本就不会退出，这就让join()失效了。这时就需要用到CountDownLatch方法了

```java
ExecutorService pool = Executors.newFixedThreadPool(2);
CountDownLatch countDownLatch = new CountDownLatch(2);

pool.execute(() -> {
    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("t1");
    System.out.println(countDownLatch.getCount());
    countDownLatch.countDown();
});

pool.execute(() -> {
    try {
        Thread.sleep(4000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("t2");
    System.out.println(countDownLatch.getCount());
    countDownLatch.countDown();
});

try {
    countDownLatch.await();
    System.out.println("end");
} catch (InterruptedException e) {
    e.printStackTrace();
}
```

CountDownLatch在创建的时候可以设置一个初始值。上面的例子为2。每次调用countDown()就会减1。当主线程调用await()的时候，如果这个计数的值不为0，则会开始等待，等到该值为0的时候才会重新运行。	

## CyclicBarrier 实现线程同步

它的作用就是会让所有线程都等待完成后才会继续下一步行动。例如：一个线程组的线程需要等待所有线程完成任务后再继续执行下一次任务





# 并发容器

